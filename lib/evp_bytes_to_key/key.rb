require 'digest/md5'

module EvpBytesToKey
  # This class is used to generate a new encryption key from a password in a way that is compatible with
  # EVP_KeyToBytes() from OpenSSL.
  class Key
    # @return [String] the value in the named format
    attr_accessor :key, :hex_key, :iv, :hex_iv
    private :key=, :hex_key=, :iv=, :hex_iv

    # Generate a key from a given password. This key is identical to the key generated
    # by EVP_KeyToBytes() in the openssl command-line utility.
    #
    # @param password [String] the password used for key generation
    # @param salt [String, nil] the salt used for key generation
    # @param bits [Integer] the bit length of the key, must be divisible by 8
    # @param iv_length [Integer] the byte length of the IV
    #
    # @return [EvpBytesToKey::Key]
    def initialize(password=nil, salt=nil, bits=nil, iv_length=nil)
      validate_arguments!({ :password => password, :salt => salt, :bits => bits, :iv_length => iv_length })

      @password = password
      @salt = salt
      @bits = bits
      @iv_length = iv_length

      generate_key!
    end

    private

    # Validates all the arguments passed to initialize
    #
    # @param args [Hash] The arguments passed to initialize
    # @raise [EvpBytesToKey::ArgumentError]
    def validate_arguments!(args)
      raise EvpBytesToKey::ArgumentError.new('password must be a String') unless args[:password].is_a?(String)

      if args[:salt]
        unless args[:salt].is_a?(String) && args[:salt].bytesize == 8
          raise EvpBytesToKey::ArgumentError.new('salt must be an 8 byte String')
        end
      end

      unless args[:bits].is_a?(Integer) && args[:bits] >= 0 && args[:bits] % 8 == 0
        raise EvpBytesToKey::ArgumentError.new('bits must be a non-negative Integer evenly divisible by 8')
      end

      unless args[:iv_length].is_a?(Integer) && args[:iv_length] >= 0 && args[:iv_length] % 2 == 0
        raise EvpBytesToKey::ArgumentError.new('iv_length must be an even Integer >= 0')
      end
    end

    # Generate a key from the supplied arguments by iteratively hashing the values and adding them
    # to bytes until bytes has been fully populated
    #
    # @return [String] the hexadecimal string representation of the generated key
    def generate_key!
      bytes = ''

      loop do
        # Set bytes to the complete string generated by the hashing process
        bytes = bytes + Digest::MD5.digest(bytes + @password + @salt.to_s)

        # If that string is long enough to include both the key and iv then set the key and the iv
        if bytes.bytesize >= (key_length) + @iv_length.to_i
          self.key = bytes.unpack('C*').take(key_length).pack('C*')
          self.hex_key = self.key.unpack('H*').first

          self.iv = bytes.unpack('C*')[key_length..key_length + @iv_length - 1].pack('C*')
          self.hex_iv = self.iv.unpack('H*').first
          break
        end
      end
    end

    # @return [Integer] the final size of the key in bytes
    def key_length
      @bits / 8
    end
  end
end
